#!/bin/bash

# Created by argbash-init v2.10.0
# ARG_LEFTOVERS([])
# ARG_OPTIONAL_BOOLEAN([dry-run],[d])
# ARG_HELP([container runner])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='dh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_leftovers=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_dry_run="off"


print_help()
{
	printf '%s\n' "container runner"
	printf 'Usage: %s [-d|--(no-)dry-run] [-h|--help] ... \n' "$0"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--no-dry-run|--dry-run)
				_arg_dry_run="on"
				test "${1:0:5}" = "--no-" && _arg_dry_run="off"
				;;
			-d*)
				_arg_dry_run="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names=""
	_our_args=$((${#_positionals[@]} - 0))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_leftovers[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

cmd () {
  set -x
  "$@"
  { set +x; } 2>/dev/null
}
export -f cmd

set -eo pipefail

export GID=$(id -g)
project_root="$(realpath "$(dirname "$0")/..")"

container_name="$(basename "$project_root")-dev"
image_name="leobastiani/leobastiani:$(basename "$project_root")-dev"

dockerfile="$(cat <<EOF
FROM --platform=linux/amd64 ubuntu

ENV DEBIAN_FRONTEND noninteractive
ENV LANG="C.UTF-8"
ENV TZ=America/Sao_Paulo

RUN ln -snf /usr/share/zoneinfo/\$TZ /etc/localtime && echo \$TZ > /etc/timezone

RUN apt-get update && \
  apt-get install -y sudo tzdata

RUN useradd -ms /bin/bash -d $HOME -u $UID -g $GID $USER && \
  usermod -aG sudo $USER

RUN echo '$USER ALL=(ALL:ALL) NOPASSWD:ALL' >> /etc/sudoers

USER $USER
WORKDIR $HOME

RUN sudo apt-get install dumb-init zsh curl wget net-tools iputils-ping netcat lsof jq -y
ENV PATH="$HOME/.meteor:\${PATH}"

ENTRYPOINT ["dumb-init"]

RUN curl https://install.meteor.com/ | sh
RUN meteor --version
RUN meteor npm install -g yarn

RUN mkdir -p "$project_root"

COPY bin/node $HOME/.meteor
COPY bin/yarn $HOME/.meteor
COPY bin/npm $HOME/.meteor
EOF
)"

if [ "$_arg_dry_run" = "on" ]; then
  echo "$dockerfile" | bat --paging=never --file-name Dockerfile
  exit 0
fi

docker_container_id=$(docker ps -a -q -f name=$container_name)

if [ -z "$docker_container_id" ]; then
  echo "$dockerfile" | docker build -t "$image_name" -f - .
  docker run \
    -d \
    --platform=linux/amd64 \
    --name $container_name \
    -p "3000-3010:3000-3010" \
    -p "9229:9229" \
    -p "9222:9222" \
    -v "$project_root:$project_root" \
    -w "$project_root" \
    -u "$UID:$GID" \
    "$image_name" \
    tail -f /dev/null > /dev/null
else
  container_status=$(docker container inspect -f '{{.State.Status}}' $container_name 2>/dev/null)

  if [ "$container_status" != "running" ]; then
    docker start $container_name > /dev/null
  fi
fi

docker exec -it -w "$PWD" -e MONGO_URL $container_name "$@"

# ] <-- needed because of Argbash
